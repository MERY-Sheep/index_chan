// Context Generation for MCP
// gather_context の実装

use std::path::Path;
use std::collections::{HashMap, HashSet};
use anyhow::Result;

use crate::graph::{CodeGraph, CodeNode, NodeId};
use crate::scanner::Scanner;

/// Context output mode
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ContextMode {
    Full,     // Complete code
    Skeleton, // Signatures only
}

impl Default for ContextMode {
    fn default() -> Self {
        Self::Full
    }
}

/// Context generation result
#[derive(Debug, Clone)]
pub struct ContextResult {
    pub content: String,
    pub files_count: usize,
    pub functions_count: usize,
    pub total_lines: usize,
}

/// Context generator
pub struct ContextGenerator {
    graph: CodeGraph,
}

impl ContextGenerator {
    /// Create from directory scan
    pub fn from_directory(directory: &Path) -> Result<Self> {
        let mut scanner = Scanner::new()?;
        let graph = scanner.scan_directory(directory)?;
        Ok(Self { graph })
    }

    /// Create from existing graph
    pub fn from_graph(graph: CodeGraph) -> Self {
        Self { graph }
    }

    /// Gather context for a function with dependencies
    pub fn gather_context(
        &self,
        entry_point: Option<&str>,
        query: Option<&str>,
        depth: usize,
        mode: ContextMode,
    ) -> Result<ContextResult> {
        let mut collected_nodes: Vec<&CodeNode> = Vec::new();
        let mut visited: HashSet<NodeId> = HashSet::new();

        // Find entry point node(s)
        let start_nodes: Vec<&CodeNode> = if let Some(entry) = entry_point {
            self.graph.nodes.values()
                .filter(|n| n.name == entry || n.name.contains(entry))
                .collect()
        } else if let Some(_q) = query {
            // TODO: Use search index for query-based lookup
            self.graph.nodes.values().take(10).collect()
        } else {
            return Ok(ContextResult {
                content: "// No entry point or query specified".to_string(),
                files_count: 0,
                functions_count: 0,
                total_lines: 0,
            });
        };

        // BFS to collect dependencies
        for node in &start_nodes {
            self.collect_dependencies(node, depth, &mut collected_nodes, &mut visited);
        }

        // Generate output
        let content = self.format_context(&collected_nodes, mode, entry_point, query);
        let files: HashSet<_> = collected_nodes.iter().map(|n| &n.file_path).collect();

        Ok(ContextResult {
            content,
            files_count: files.len(),
            functions_count: collected_nodes.len(),
            total_lines: collected_nodes.iter().map(|n| n.line_range.1 - n.line_range.0 + 1).sum(),
        })
    }

    /// Collect dependencies recursively
    fn collect_dependencies<'a>(
        &'a self,
        node: &'a CodeNode,
        depth: usize,
        collected: &mut Vec<&'a CodeNode>,
        visited: &mut HashSet<NodeId>,
    ) {
        if visited.contains(&node.id) || depth == 0 {
            return;
        }
        visited.insert(node.id);
        collected.push(node);

        if depth > 0 {
            // Find edges from this node
            for edge in &self.graph.edges {
                if edge.from == node.id {
                    if let Some(target) = self.graph.nodes.get(&edge.to) {
                        self.collect_dependencies(target, depth - 1, collected, visited);
                    }
                }
            }
        }
    }

    /// Format collected nodes into context string
    fn format_context(
        &self,
        nodes: &[&CodeNode],
        mode: ContextMode,
        entry_point: Option<&str>,
        query: Option<&str>,
    ) -> String {
        let mut output = String::new();

        // Header
        output.push_str("// ===== CONTEXT FILE =====\n");
        output.push_str("// Generated by index-chan\n");
        if let Some(entry) = entry_point {
            output.push_str(&format!("// Entry point: {}\n", entry));
        }
        if let Some(q) = query {
            output.push_str(&format!("// Query: {}\n", q));
        }

        // Group by file
        let mut by_file: HashMap<&std::path::PathBuf, Vec<&CodeNode>> = HashMap::new();
        for node in nodes {
            by_file.entry(&node.file_path).or_default().push(*node);
        }

        output.push_str(&format!("// Files: {}, Functions: {}\n\n", by_file.len(), nodes.len()));

        // Output each file
        for (file_path, file_nodes) in by_file {
            output.push_str(&format!("// ===== FILE: {} =====\n", file_path.display()));

            for node in file_nodes {
                output.push_str(&format!("// Lines: {}-{}\n\n", node.line_range.0, node.line_range.1));

                match mode {
                    ContextMode::Full => {
                        // Read actual code from file
                        if let Ok(code) = self.read_code_range(file_path, node.line_range) {
                            output.push_str(&code);
                        } else {
                            output.push_str(&format!("// {} {:?}\n", node.name, node.node_type));
                        }
                    }
                    ContextMode::Skeleton => {
                        // Output signature only
                        output.push_str(&format!("{} {:?} // ...\n", node.name, node.node_type));
                    }
                }
                output.push_str("\n");
            }
        }

        output.push_str("// ===== END CONTEXT =====\n");
        output
    }

    /// Read code from file at specific line range
    fn read_code_range(&self, file_path: &Path, range: (usize, usize)) -> Result<String> {
        let content = std::fs::read_to_string(file_path)?;
        let lines: Vec<&str> = content.lines().collect();

        let start = range.0.saturating_sub(1);
        let end = range.1.min(lines.len());

        Ok(lines[start..end].join("\n"))
    }

    /// Get dependencies of a function
    pub fn get_dependencies(&self, function_name: &str, depth: usize) -> Vec<DependencyInfo> {
        let mut result = Vec::new();
        let mut visited = HashSet::new();

        // Find the function
        let start_node = self.graph.nodes.values()
            .find(|n| n.name == function_name);

        if let Some(node) = start_node {
            self.collect_dependency_info(node, depth, &mut result, &mut visited, true);
        }

        result
    }

    /// Get dependents (reverse dependencies) of a function
    pub fn get_dependents(&self, function_name: &str, depth: usize) -> Vec<DependencyInfo> {
        let mut result = Vec::new();
        let mut visited = HashSet::new();

        // Find the function
        let start_node = self.graph.nodes.values()
            .find(|n| n.name == function_name);

        if let Some(node) = start_node {
            self.collect_dependency_info(node, depth, &mut result, &mut visited, false);
        }

        result
    }

    fn collect_dependency_info<'a>(
        &'a self,
        node: &'a CodeNode,
        depth: usize,
        result: &mut Vec<DependencyInfo>,
        visited: &mut HashSet<NodeId>,
        forward: bool, // true = dependencies, false = dependents
    ) {
        if visited.contains(&node.id) || depth == 0 {
            return;
        }
        visited.insert(node.id);

        for edge in &self.graph.edges {
            let (source, target) = if forward {
                (&edge.from, &edge.to)
            } else {
                (&edge.to, &edge.from)
            };

            if source == &node.id {
                if let Some(target_node) = self.graph.nodes.get(target) {
                    result.push(DependencyInfo {
                        name: target_node.name.clone(),
                        file_path: target_node.file_path.display().to_string(),
                        line: target_node.line_range.0,
                        node_type: format!("{:?}", target_node.node_type),
                    });

                    if depth > 1 {
                        self.collect_dependency_info(target_node, depth - 1, result, visited, forward);
                    }
                }
            }
        }
    }
}

/// Dependency information
#[derive(Debug, Clone, serde::Serialize)]
pub struct DependencyInfo {
    pub name: String,
    pub file_path: String,
    pub line: usize,
    pub node_type: String,
}
